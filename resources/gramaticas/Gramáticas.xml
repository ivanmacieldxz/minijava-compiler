<Inicial> --> <ListaClases> eof
<ListaClases> --> <Clase> <ListaClases> | e
<Clase> --> <ModificadorOpcional> class idClase <HerenciaOpcional> { <ListaMiembros> }
<ModificadorOpcional> --> abstract | static | final | e
<HerenciaOpcional> --> extends idClase | e
<ListaMiembros> --> <Miembro> <ListaMiembros> | e
<Miembro> --> <Atributo> | <Metodo> | <Constructor>
<Atributo> --> <Tipo> idMetVar ;
<Metodo> --> <ModificadorOpcional> <TipoMetodo> idMetVar <ArgsFormales> <BloqueOpcional>
<Constructor> --> public idClase <ArgsFormales> <Bloque>
<TipoMetodo> --> <Tipo> | void
<Tipo> --> <TipoPrimitivo> | idClase
<TipoPrimitivo> --> boolean | char | int
<ArgsFormales> --> ( <ListaArgsFormalesOpcional> )
<ListaArgsFormalesOpcional> --> <ListaArgsFormales> | e
<ListaArgsFormales> --> <ArgFormal>
<ListaArgsFormales> --> <ListaArgsFormales> , <ArgFormal>
<ArgFormal> --> <Tipo> idMetVar
<BloqueOpcional> --> <Bloque> | ;
<Bloque> --> { <ListaSentencias> }
<ListaSentencias> --> <Sentencia> <ListaSentencias> | e
<Sentencia> --> ;
<Sentencia> --> <Asignacion> ;
<Sentencia> --> <Llamada> ;
<Sentencia> --> <VarLocal> ;
<Sentencia> --> <Return> ;
<Sentencia> --> <If>
<Sentencia> --> <While>
<Sentencia> --> <Bloque>
<Asignacion> --> <Expresion>
<llamada> --> <Expresion>
<VarLocal> --> var idMetVar = <ExpresionCompuesta>
<Return> --> return <ExpresionOpcional>
<ExpresionOpcional> --> <Expresion> | e
<If> --> if ( <Expresion> ) <Sentencia>
<If> --> if ( <Expresion> ) <Sentencia> else <Sentencia>
<While> --> while ( <Expresion> ) <Sentencia>
<Expresion> --> <ExpresionCompuesta> <OperadorAsignacion> <ExpresionCompuesta>
<Expresion> --> <ExpresionCompuesta>
<OperadorAsignacion> --> =
<ExpresionCompuesta> --> <ExpresionCompuesta> <OperadorBinario> <ExpresionBasica>
<ExpresionCompuesta> --> <ExpresionBasica>
<OperadorBinario> --> || | && | == | != | < | > | <= | >= | + | - | * | / | %
<ExpresionBasica> --> <OperadorUnario> <Operando>
<ExpresionBasica> --> <Operando>
<OperadorUnario> --> + | ++ | - | -- | !
<Operando> --> <Primitvo>
<Operando> --> <Referencia>
<Primitivo> --> true | false | intLiteral | charLiteral | null
<Referencia> --> <Primario>
<Referencia> --> <Referencia> <VarEncadenada>
<Referencia> --> <Referencia> <MetodoEncadenado>
<Primario> --> this
<Primario> --> stringLiteral
<Primario> --> <AccesoVar>
<Primario> --> <LlamadaConstructor>
<Primario> --> <LlamadaMetodo>
<Primario> --> <LlamadaMetodoEstatico>
<Primario> --> <ExpresionParentizada>
<AccesoVar> --> idMetVar
<LlamadaConstructor> --> new idClase <ArgsActuales>
<ExpresionParentizada> --> ( <Expresion> )
<LlamadaMetodo> --> idMetVar <ArgsActuales>
<LlamadaMetodoEstatico> --> idClase . idMetVar <ArgsActuales>
<ArgsActuales> --> ( <ListaExpsOpcional> )
<ListaExpsOpcional> --> <ListaExps> | e
<ListaExps> --> <Expresion>
<ListaExps> --> <Expresion> , <ListaExps>
<VarEncadenada> --> . idMetVar
<MetodoEncadenado> --> . idMetVar <ArgsActuales>

Gramática pos-eliminación de recursión a izquierda:

<Inicial> --> <ListaClases> eof
<ListaClases> --> <Clase> <ListaClases> | e
<Clase> --> <ModificadorOpcional> class idClase <HerenciaOpcional> { <ListaMiembros> }
<ModificadorOpcional> --> abstract | static | final | e
<HerenciaOpcional> --> extends idClase | e
<ListaMiembros> --> <Miembro> <ListaMiembros> | e
<Miembro> --> <Atributo> | <Metodo> | <Constructor>
<Atributo> --> <Tipo> idMetVar ;
<Metodo> --> <ModificadorOpcional> <TipoMetodo> idMetVar <ArgsFormales> <BloqueOpcional>
<Constructor> --> public idClase <ArgsFormales> <Bloque>
<TipoMetodo> --> <Tipo> | void
<Tipo> --> <TipoPrimitivo> | idClase
<TipoPrimitivo> --> boolean | char | int
<ArgsFormales> --> ( <ListaArgsFormalesOpcional> )
<ListaArgsFormalesOpcional> --> <ListaArgsFormales> | e
<ListaArgsFormales> --> <ArgFormal> <RestoListaArgsFormales>
<RestoListaArgsFormales> --> , <ListaArgsFormales> | e
<ArgFormal> --> <Tipo> idMetVar
<BloqueOpcional> --> <Bloque> | ;
<Bloque> --> { <ListaSentencias> }
<ListaSentencias> --> <Sentencia> <ListaSentencias> | e
<Sentencia> --> ;
<Sentencia> --> <Asignacion> ;
<Sentencia> --> <Llamada> ;
<Sentencia> --> <VarLocal> ;
<Sentencia> --> <Return> ;
<Sentencia> --> <If>
<Sentencia> --> <While>
<Sentencia> --> <Bloque>
<Asignacion> --> <Expresion>
<Llamada> --> <Expresion>
<VarLocal> --> var idMetVar = <ExpresionCompuesta>
<Return> --> return <ExpresionOpcional>
<ExpresionOpcional> --> <Expresion> | e
<If> --> if ( <Expresion> ) <Sentencia>
<If> --> if ( <Expresion> ) <Sentencia> else <Sentencia>
<While> --> while ( <Expresion> ) <Sentencia>
<Expresion> --> <ExpresionCompuesta> <OperadorAsignacion> <ExpresionCompuesta>
<Expresion> --> <ExpresionCompuesta>
<OperadorAsignacion> --> =
<ExpresionCompuesta> --> <ExpresionBasica> <RestoExpresionCompuesta>
<RestoExpresionCompuesta> --> <OperadorBinario> <ExpresionBasica> <RestoExpresionCompuesta> | e
<OperadorBinario> --> || | && | == | != | < | > | <= | >= | + | - | * | / | %
<ExpresionBasica> --> <OperadorUnario> <Operando>
<ExpresionBasica> --> <Operando>
<OperadorUnario> --> + | ++ | - | -- | !
<Operando> --> <Primitivo>
<Operando> --> <Referencia>
<Primitivo> --> true | false | intLiteral | charLiteral | null
<Referencia> --> <Primario> <RestoReferencia>
<RestoReferencia> --> <VarEncadenada> <RestoReferencia> | <MetodoEncadenado> <RestoReferencia> | e
<Primario> --> this
<Primario> --> stringLiteral
<Primario> --> <AccesoVar>
<Primario> --> <LlamadaConstructor>
<Primario> --> <LlamadaMetodo>
<Primario> --> <LlamadaMetodoEstatico>
<Primario> --> <ExpresionParentizada>
<AccesoVar> --> idMetVar
<LlamadaConstructor> --> new idClase <ArgsActuales>
<ExpresionParentizada> --> ( <Expresion> )
<LlamadaMetodo> --> idMetVar <ArgsActuales>
<LlamadaMetodoEstatico> --> idClase . idMetVar <ArgsActuales>
<ArgsActuales> --> ( <ListaExpsOpcional> )
<ListaExpsOpcional> --> <ListaExps> | e
<ListaExps> --> <Expresion>
<ListaExps> --> <Expresion> , <ListaExps>
<VarEncadenada> --> . idMetVar
<MetodoEncadenado> --> . idMetVar <ArgsActuales>

Gramática pos-eliminación de problemas de factorización:

<Inicial> --> <ListaClases> eof
<ListaClases> --> <Clase> <ListaClases> | e
<Clase> --> <ModificadorOpcional> class idClase <HerenciaOpcional> { <ListaMiembros> }
<ModificadorOpcional> --> abstract | static | final | e
<HerenciaOpcional> --> extends idClase | e
<ListaMiembros> --> <Miembro> <ListaMiembros> | e
<Miembro> --> <Tipo> <RestoDeclaracionMiembro> |
    void idMetVar <RestoDeclaracionMetodo> |
    <Modificador> <TipoMetodo> idMetVar <RestoDeclaracionMetodo> |
    <Constructor>
<Modificador> --> abstract | static | final
<RestoDeclaracionMiembro> --> idMetVar <FinDeclaracionMiembro>
<FinDeclaracionMiembro> --> ; | <RestoDeclaracionMetodo>
<RestoDeclaracionMetodo> --> <ArgsFormales> <BloqueOpcional>
<Constructor> --> public idClase <ArgsFormales> <Bloque>
<TipoMetodo> --> <Tipo> | void
<Tipo> --> <TipoPrimitivo> | idClase
<TipoPrimitivo> --> boolean | char | int
<ArgsFormales> --> ( <ListaArgsFormalesOpcional> )
<ListaArgsFormalesOpcional> --> <ListaArgsFormales> | e
<ListaArgsFormales> --> <ArgFormal> <RestoListaArgsFormales>
<RestoListaArgsFormales> --> , <ListaArgsFormales> | e
<ArgFormal> --> <Tipo> idMetVar
<BloqueOpcional> --> <Bloque> | ;
<Bloque> --> { <ListaSentencias> }
<ListaSentencias> --> <Sentencia> <ListaSentencias> | e
<Sentencia> --> ;
<Sentencia> --> <Expresion> ;
<Sentencia> --> <VarLocal> ;
<Sentencia> --> <Return> ;
<Sentencia> --> <If>
<Sentencia> --> <While>
<Sentencia> --> <Bloque>
<VarLocal> --> var idMetVar = <ExpresionCompuesta>
<Return> --> return <ExpresionOpcional>
<ExpresionOpcional> --> <Expresion> | e
<If> --> if ( <Expresion> ) <Sentencia> <ElseOpcional>
<ElseOpcional> --> else <Sentencia> | e
<While> --> while ( <Expresion> ) <Sentencia>
<Expresion> --> <ExpresionCompuesta> <RestoExpresion>
<RestoExpresion> --> <OperadorAsignacion> <ExpresionCompuesta> | e
<OperadorAsignacion> --> =
<ExpresionCompuesta> --> <ExpresionBasica> <RestoExpresionCompuesta>
<RestoExpresionCompuesta> --> <OperadorBinario> <ExpresionBasica> <RestoExpresionCompuesta> | e
<OperadorBinario> --> || | && | == | != | < | > | <= | >= | + | - | * | / | %
<ExpresionBasica> --> <OperadorUnario> <Operando>
<ExpresionBasica> --> <Operando>
<OperadorUnario> --> + | ++ | - | -- | !
<Operando> --> <Primitivo>
<Operando> --> <Referencia>
<Primitivo> --> true | false | intLiteral | charLiteral | null
<Referencia> --> <Primario> <RestoReferencia>
<RestoReferencia> --> <MetVarEncadenada> <RestoReferencia> | e
<Primario> --> this
<Primario> --> stringLiteral
<Primario> --> <AccesoVarLlamadaMet>
<Primario> --> <LlamadaConstructor>
<Primario> --> <LlamadaMetodoEstatico>
<Primario> --> <ExpresionParentizada>
<AccesoVarLlamadaMet> --> idMetVar <RestoLlamadaMetOpcional>
<RestoLlamadaMetOpcional> --> <ArgsActuales> | e
<LlamadaConstructor> --> new idClase <ArgsActuales>
<ExpresionParentizada> --> ( <Expresion> )
<LlamadaMetodoEstatico> --> idClase . idMetVar <ArgsActuales>
<ArgsActuales> --> ( <ListaExpsOpcional> )
<ListaExpsOpcional> --> <ListaExps> | e
<ListaExps> --> <Expresion> <RestoListaExps>
<RestoListaExps> --> , <ListaExps> | e
<MetVarEncadenada> --> . idMetVar <RestoDeEncadenamiento>
<RestoDeEncadenamiento> --> <ArgsActuales> | e